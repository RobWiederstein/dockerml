name: Run Docker Pipeline and Deploy Report

on:
  push:
    branches:
      - main
      - master

jobs:
  build-run-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub (Optional - only if pulling private base or pushing)
        # if: github.event_name != 'pull_request' # Example condition
        # uses: docker/login-action@v3
        # with:
        #   username: ${{ secrets.DOCKERHUB_USERNAME }}
        #   password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Build the base image with GHA caching
      - name: Build base Docker image
        uses: docker/build-push-action@v5
        with:
          context: . # Assuming Dockerfile.base is in the root
          file: ./Dockerfile.base
          # Build for amd64, as your base image internals are set up for this
          platforms: linux/amd64
          push: false # Do not push base image, just build and load for next step
          tags: robwiederstein/r-ml-base:4.4.0
          # Cache configuration using GitHub Actions cache
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build the pipeline image with GHA caching, using the base image just built
      - name: Build pipeline Docker image
        uses: docker/build-push-action@v5
        with:
          context: . # Assuming Dockerfile is in the root
          file: ./Dockerfile
          # Build for amd64, as your compose file specifies this
          platforms: linux/amd64
          push: false # Do not push pipeline image, just build for 'docker compose up'
          tags: dockerml-project:latest # Tag matches your compose.yaml
          # Cache configuration using GitHub Actions cache
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Make run_pipeline.sh executable
        run: chmod +x ./run_pipeline.sh

      - name: Run the full pipeline (using pre-built images)
        # Modify run_pipeline.sh to NOT use --build in CI, or it will ignore the cached images from above.
        # For now, let's assume run_pipeline.sh still contains 'docker compose up --build',
        # which will re-check layers, but should be fast if base image is identical.
        # Ideally, run_pipeline.sh would just be 'docker compose up' in CI.
        run: ./run_pipeline.sh

      # Optional deployment step remains the same
      - name: Deploy report to GitHub Pages
        if: success() # Only deploy if pipeline ran successfully
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
